Dans ce projet on utilise les modules suivants:
Tkinter: La partie graphique
Numpy: Fournit la loi de Poisson
Random: Pour la vitesse des liens
Collections: Pour prendre en charge les erreurs de type


Il y'a plusieurs classes:

Queue: C'est une classe qui permet d'avoir des opérations de type FIFO, premier entré premier sorti. C'est pratique pour mettre en place un système de file d'attente. On utilise une liste pour stocker les éléments, on garde en mémoire le dernier élément qu'on à enlevé, et on peut y définir une taille maximale.
Pour ce qui est du contexte, on utilise des Packets et la taille de ces packets.
Les méthodes permettent de retirer les packets vides (dont l'attribut .size est 0), de vider la file (le plus important en vidant les packets avec "transmit_packets") en fonction d'un nombre maximal qui représente la vitesse du lien, de connaître le remplissage et enfin de connaître le taux de perte. Pour cela, à chaque fois que l'on rajoute des Packets on vérifie qu'il reste de la place, si c'est le cas alors le Packet est ajouté sinon il est perdu. On compte à l'aide d'un dictionnaire les succès et les pertes.

Packet:
Représente un packet de donnée de manière grossière. Il n'y a rien de spécial à cette classe, elle contient deux attributs, la taille et un potentiel identifiant (On peut y mettre n'importe quoi, mais on peut identifer la source du packet par exemple).

Jusqu'à présent, le travail est fait et fonctionnel, les classes suivantes ne sont pas encore terminées.

Buffer: La classe la plus complète et la plus compliquée. Il s'agit d'un widget custom qui est en faite un regroupement d'éléments. Il y'a une barre de progression pour visuelement voir le taux de remplissage, des labels pour y voir les informations, des Scale pour modifier les variables et les variables Tkinter qui vont avec. Cela utilise la classe Queue pour le stockage et obtenir les informations.

Client: Il s'agit d'une source de Packets, qui peux générer une liste de Packets en fonction d'une loi de poisson et donc d'un λ(lambda) associé. Il n'a que deux méthodes, pour créer les packets et les envoyer à un object Queue.

Pour rendre le tout dynamique il faut mettre à jour les éléments. On utilise pour cela la fonction main_loop qui va mettre à jour chaque Buffer.

Le problème des classes Buffer et Client sont les suivants:
Chaque Buffer n'est relié qu'à un seul Client
Un Buffer contient le client alors que ça devrait être séparé
On créer un Buffer pour chaque client et un Buffer principal.
On doit pouvoir relier les client au buffer principal

C'est pour ça que je me dis qu'il serait intéressant de fusionner la Classe Buffer et Client (La partie graphique au moins) et de les différencier.
On peut essayer l'héritage de classe où la base c'est la partie graphique, et les fonctions et méthodes sont des classes qui héritent de cette partie graphique. La classe de base ne s'appelerait plus Buffer mais autre chose, laissant la possibilité de créer les classes Buffer et Client.

Il reste à créer les stratégies de vidage, le buffer principal choisit les clients à vider selon certains critères (voir le pdf). Graphiquement on peut utiliser des Radio Button (https://www.tutorialspoint.com/python/tk_radiobutton.htm) qui permettent de faire un choix unique parmi une séléction.

Pour les détails de code il faut regarder les docstrings, ils contiennent les informations nécessaires, surtout pour les kwargs.
